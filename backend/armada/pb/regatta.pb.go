// Copyright JAMF Software, LLC

//
// Regatta protobuffer specification
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: regatta.proto

package regattapb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	structpb "google.golang.org/protobuf/types/known/structpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ResponseHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// shard_id is the ID of the shard which sent the response.
	ShardId uint64 `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	// replica_id is the ID of the member which sent the response.
	ReplicaId uint64 `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	// revision is the key-value store revision when the request was applied.
	Revision uint64 `protobuf:"varint,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// raft_term is the raft term when the request was applied.
	RaftTerm uint64 `protobuf:"varint,4,opt,name=raft_term,json=raftTerm,proto3" json:"raft_term,omitempty"`
	// raft_leader_id is the ID of the actual raft quorum leader.
	RaftLeaderId  uint64 `protobuf:"varint,5,opt,name=raft_leader_id,json=raftLeaderId,proto3" json:"raft_leader_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResponseHeader) Reset() {
	*x = ResponseHeader{}
	mi := &file_regatta_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResponseHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResponseHeader) ProtoMessage() {}

func (x *ResponseHeader) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResponseHeader.ProtoReflect.Descriptor instead.
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{0}
}

func (x *ResponseHeader) GetShardId() uint64 {
	if x != nil {
		return x.ShardId
	}
	return 0
}

func (x *ResponseHeader) GetReplicaId() uint64 {
	if x != nil {
		return x.ReplicaId
	}
	return 0
}

func (x *ResponseHeader) GetRevision() uint64 {
	if x != nil {
		return x.Revision
	}
	return 0
}

func (x *ResponseHeader) GetRaftTerm() uint64 {
	if x != nil {
		return x.RaftTerm
	}
	return 0
}

func (x *ResponseHeader) GetRaftLeaderId() uint64 {
	if x != nil {
		return x.RaftLeaderId
	}
	return 0
}

type RangeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// table name of the table
	Table []byte `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	// key is the first key for the range. If range_end is not given, the request only looks up key.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// range_end is the upper bound on the requested range [key, range_end).
	// If range_end is '\0', the range is all keys >= key.
	// If range_end is key plus one (e.g., "aa"+1 == "ab", "a\xff"+1 == "b"),
	// then the range request gets all keys prefixed with key.
	// If both key and range_end are '\0', then the range request returns all keys.
	RangeEnd []byte `protobuf:"bytes,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	// limit is a limit on the number of keys returned for the request. When limit is set to 0,
	// it is treated as no limit.
	Limit int64 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	// linearizable sets the range request to use linearizable read. Linearizable requests
	// have higher latency and lower throughput than serializable requests but reflect the current
	// consensus of the cluster. For better performance, in exchange for possible stale reads,
	// a serializable range request is served locally without needing to reach consensus
	// with other nodes in the cluster. The serializable request is default option.
	Linearizable bool `protobuf:"varint,5,opt,name=linearizable,proto3" json:"linearizable,omitempty"`
	// keys_only when set returns only the keys and not the values.
	KeysOnly bool `protobuf:"varint,6,opt,name=keys_only,json=keysOnly,proto3" json:"keys_only,omitempty"`
	// count_only when set returns only the count of the keys in the range.
	CountOnly bool `protobuf:"varint,7,opt,name=count_only,json=countOnly,proto3" json:"count_only,omitempty"`
	// min_mod_revision is the lower bound for returned key mod revisions; all keys with
	// lesser mod revisions will be filtered away.
	MinModRevision int64 `protobuf:"varint,8,opt,name=min_mod_revision,json=minModRevision,proto3" json:"min_mod_revision,omitempty"`
	// max_mod_revision is the upper bound for returned key mod revisions; all keys with
	// greater mod revisions will be filtered away.
	MaxModRevision int64 `protobuf:"varint,9,opt,name=max_mod_revision,json=maxModRevision,proto3" json:"max_mod_revision,omitempty"`
	// min_create_revision is the lower bound for returned key create revisions; all keys with
	// lesser create revisions will be filtered away.
	MinCreateRevision int64 `protobuf:"varint,10,opt,name=min_create_revision,json=minCreateRevision,proto3" json:"min_create_revision,omitempty"`
	// max_create_revision is the upper bound for returned key create revisions; all keys with
	// greater create revisions will be filtered away.
	MaxCreateRevision int64 `protobuf:"varint,11,opt,name=max_create_revision,json=maxCreateRevision,proto3" json:"max_create_revision,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RangeRequest) Reset() {
	*x = RangeRequest{}
	mi := &file_regatta_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RangeRequest) ProtoMessage() {}

func (x *RangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RangeRequest.ProtoReflect.Descriptor instead.
func (*RangeRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{1}
}

func (x *RangeRequest) GetTable() []byte {
	if x != nil {
		return x.Table
	}
	return nil
}

func (x *RangeRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *RangeRequest) GetRangeEnd() []byte {
	if x != nil {
		return x.RangeEnd
	}
	return nil
}

func (x *RangeRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *RangeRequest) GetLinearizable() bool {
	if x != nil {
		return x.Linearizable
	}
	return false
}

func (x *RangeRequest) GetKeysOnly() bool {
	if x != nil {
		return x.KeysOnly
	}
	return false
}

func (x *RangeRequest) GetCountOnly() bool {
	if x != nil {
		return x.CountOnly
	}
	return false
}

func (x *RangeRequest) GetMinModRevision() int64 {
	if x != nil {
		return x.MinModRevision
	}
	return 0
}

func (x *RangeRequest) GetMaxModRevision() int64 {
	if x != nil {
		return x.MaxModRevision
	}
	return 0
}

func (x *RangeRequest) GetMinCreateRevision() int64 {
	if x != nil {
		return x.MinCreateRevision
	}
	return 0
}

func (x *RangeRequest) GetMaxCreateRevision() int64 {
	if x != nil {
		return x.MaxCreateRevision
	}
	return 0
}

type RangeResponse struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Header *ResponseHeader        `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// kvs is the list of key-value pairs matched by the range request.
	// kvs is empty when count is requested.
	Kvs []*KeyValue `protobuf:"bytes,3,rep,name=kvs,proto3" json:"kvs,omitempty"`
	// more indicates if there are more keys to return in the requested range.
	More bool `protobuf:"varint,4,opt,name=more,proto3" json:"more,omitempty"`
	// count is set to the number of keys within the range when requested.
	Count         int64 `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RangeResponse) Reset() {
	*x = RangeResponse{}
	mi := &file_regatta_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RangeResponse) ProtoMessage() {}

func (x *RangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RangeResponse.ProtoReflect.Descriptor instead.
func (*RangeResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{2}
}

func (x *RangeResponse) GetHeader() *ResponseHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *RangeResponse) GetKvs() []*KeyValue {
	if x != nil {
		return x.Kvs
	}
	return nil
}

func (x *RangeResponse) GetMore() bool {
	if x != nil {
		return x.More
	}
	return false
}

func (x *RangeResponse) GetCount() int64 {
	if x != nil {
		return x.Count
	}
	return 0
}

type PutRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// table name of the table
	Table []byte `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	// key is the key, in bytes, to put into the key-value store.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// value is the value, in bytes, to associate with the key in the key-value store.
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// prev_kv if true the previous key-value pair will be returned in the put response.
	PrevKv        bool `protobuf:"varint,4,opt,name=prev_kv,json=prevKv,proto3" json:"prev_kv,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutRequest) Reset() {
	*x = PutRequest{}
	mi := &file_regatta_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutRequest) ProtoMessage() {}

func (x *PutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutRequest.ProtoReflect.Descriptor instead.
func (*PutRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{3}
}

func (x *PutRequest) GetTable() []byte {
	if x != nil {
		return x.Table
	}
	return nil
}

func (x *PutRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *PutRequest) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PutRequest) GetPrevKv() bool {
	if x != nil {
		return x.PrevKv
	}
	return false
}

type PutResponse struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Header *ResponseHeader        `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// if prev_kv is set in the request, the previous key-value pair will be returned.
	PrevKv        *KeyValue `protobuf:"bytes,2,opt,name=prev_kv,json=prevKv,proto3" json:"prev_kv,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutResponse) Reset() {
	*x = PutResponse{}
	mi := &file_regatta_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutResponse) ProtoMessage() {}

func (x *PutResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutResponse.ProtoReflect.Descriptor instead.
func (*PutResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{4}
}

func (x *PutResponse) GetHeader() *ResponseHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *PutResponse) GetPrevKv() *KeyValue {
	if x != nil {
		return x.PrevKv
	}
	return nil
}

type DeleteRangeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// table name of the table
	Table []byte `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	// key is the first key to delete in the range.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// range_end is the key following the last key to delete for the range [key, range_end).
	// If range_end is not given, the range is defined to contain only the key argument.
	// If range_end is one bit larger than the given key, then the range is all the keys
	// with the prefix (the given key).
	// If range_end is '\0', the range is all keys greater than or equal to the key argument.
	RangeEnd []byte `protobuf:"bytes,3,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	// If prev_kv is set, regatta gets the previous key-value pairs before deleting it.
	// The previous key-value pairs will be returned in the delete response.
	// Beware that getting previous records could have serious performance impact on a delete range spanning a large dataset.
	PrevKv bool `protobuf:"varint,4,opt,name=prev_kv,json=prevKv,proto3" json:"prev_kv,omitempty"`
	// If count is set, regatta gets the count of previous key-value pairs before deleting it.
	// The deleted field will be set to number of deleted key-value pairs in the response.
	// Beware that counting records could have serious performance impact on a delete range spanning a large dataset.
	Count         bool `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRangeRequest) Reset() {
	*x = DeleteRangeRequest{}
	mi := &file_regatta_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRangeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRangeRequest) ProtoMessage() {}

func (x *DeleteRangeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRangeRequest.ProtoReflect.Descriptor instead.
func (*DeleteRangeRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{5}
}

func (x *DeleteRangeRequest) GetTable() []byte {
	if x != nil {
		return x.Table
	}
	return nil
}

func (x *DeleteRangeRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *DeleteRangeRequest) GetRangeEnd() []byte {
	if x != nil {
		return x.RangeEnd
	}
	return nil
}

func (x *DeleteRangeRequest) GetPrevKv() bool {
	if x != nil {
		return x.PrevKv
	}
	return false
}

func (x *DeleteRangeRequest) GetCount() bool {
	if x != nil {
		return x.Count
	}
	return false
}

type DeleteRangeResponse struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Header *ResponseHeader        `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// deleted is the number of keys deleted by the delete range request.
	Deleted int64 `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
	// if prev_kv is set in the request, the previous key-value pairs will be returned.
	PrevKvs       []*KeyValue `protobuf:"bytes,3,rep,name=prev_kvs,json=prevKvs,proto3" json:"prev_kvs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRangeResponse) Reset() {
	*x = DeleteRangeResponse{}
	mi := &file_regatta_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRangeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRangeResponse) ProtoMessage() {}

func (x *DeleteRangeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRangeResponse.ProtoReflect.Descriptor instead.
func (*DeleteRangeResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{6}
}

func (x *DeleteRangeResponse) GetHeader() *ResponseHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *DeleteRangeResponse) GetDeleted() int64 {
	if x != nil {
		return x.Deleted
	}
	return 0
}

func (x *DeleteRangeResponse) GetPrevKvs() []*KeyValue {
	if x != nil {
		return x.PrevKvs
	}
	return nil
}

// From google paxosdb paper:
// Our implementation hinges around a powerful primitive which we call MultiOp. All other database
// operations except for iteration are implemented as a single call to MultiOp. A MultiOp is applied atomically
// and consists of three components:
// 1. A list of tests called guard. Each test in guard checks a single entry in the database. It may check
// for the absence or presence of a value, or compare with a given value. Two different tests in the guard
// may apply to the same or different entries in the database. All tests in the guard are applied and
// MultiOp returns the results. If all tests are true, MultiOp executes t op (see item 2 below), otherwise
// it executes f op (see item 3 below).
// 2. A list of database operations called t op. Each operation in the list is either an insert, delete, or
// lookup operation, and applies to a database entry(ies). Two different operations in the list may apply
// to the same or different entries in the database. These operations are executed
// if guard evaluates to true.
// 3. A list of database operations called f op. Like t op, but executed if guard evaluates to false.
type TxnRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// table name of the table
	Table []byte `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
	// compare is a list of predicates representing a conjunction of terms.
	// If the comparisons succeed, then the success requests will be processed in order,
	// and the response will contain their respective responses in order.
	// If the comparisons fail, then the failure requests will be processed in order,
	// and the response will contain their respective responses in order.
	Compare []*Compare `protobuf:"bytes,2,rep,name=compare,proto3" json:"compare,omitempty"`
	// success is a list of requests which will be applied when compare evaluates to true.
	Success []*RequestOp `protobuf:"bytes,3,rep,name=success,proto3" json:"success,omitempty"`
	// failure is a list of requests which will be applied when compare evaluates to false.
	Failure       []*RequestOp `protobuf:"bytes,4,rep,name=failure,proto3" json:"failure,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnRequest) Reset() {
	*x = TxnRequest{}
	mi := &file_regatta_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnRequest) ProtoMessage() {}

func (x *TxnRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnRequest.ProtoReflect.Descriptor instead.
func (*TxnRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{7}
}

func (x *TxnRequest) GetTable() []byte {
	if x != nil {
		return x.Table
	}
	return nil
}

func (x *TxnRequest) GetCompare() []*Compare {
	if x != nil {
		return x.Compare
	}
	return nil
}

func (x *TxnRequest) GetSuccess() []*RequestOp {
	if x != nil {
		return x.Success
	}
	return nil
}

func (x *TxnRequest) GetFailure() []*RequestOp {
	if x != nil {
		return x.Failure
	}
	return nil
}

type TxnResponse struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Header *ResponseHeader        `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// succeeded is set to true if the compare evaluated to true or false otherwise.
	Succeeded bool `protobuf:"varint,2,opt,name=succeeded,proto3" json:"succeeded,omitempty"`
	// responses is a list of responses corresponding to the results from applying
	// success if succeeded is true or failure if succeeded is false.
	Responses     []*ResponseOp `protobuf:"bytes,3,rep,name=responses,proto3" json:"responses,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxnResponse) Reset() {
	*x = TxnResponse{}
	mi := &file_regatta_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxnResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxnResponse) ProtoMessage() {}

func (x *TxnResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxnResponse.ProtoReflect.Descriptor instead.
func (*TxnResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{8}
}

func (x *TxnResponse) GetHeader() *ResponseHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *TxnResponse) GetSucceeded() bool {
	if x != nil {
		return x.Succeeded
	}
	return false
}

func (x *TxnResponse) GetResponses() []*ResponseOp {
	if x != nil {
		return x.Responses
	}
	return nil
}

type MemberListRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MemberListRequest) Reset() {
	*x = MemberListRequest{}
	mi := &file_regatta_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MemberListRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MemberListRequest) ProtoMessage() {}

func (x *MemberListRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MemberListRequest.ProtoReflect.Descriptor instead.
func (*MemberListRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{9}
}

type MemberListResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cluster is a name of the cluster.
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// members is a list of all members associated with the cluster.
	Members       []*Member `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MemberListResponse) Reset() {
	*x = MemberListResponse{}
	mi := &file_regatta_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MemberListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MemberListResponse) ProtoMessage() {}

func (x *MemberListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MemberListResponse.ProtoReflect.Descriptor instead.
func (*MemberListResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{10}
}

func (x *MemberListResponse) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *MemberListResponse) GetMembers() []*Member {
	if x != nil {
		return x.Members
	}
	return nil
}

type Member struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the member ID of this member.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the human-readable name of the member. If the member is not started, the name will be an empty string.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// peerURLs is the list of URLs the member exposes to the cluster for communication.
	PeerURLs []string `protobuf:"bytes,3,rep,name=peerURLs,proto3" json:"peerURLs,omitempty"`
	// clientURLs is the list of URLs the member exposes to clients for communication. If the member is not started, clientURLs will be empty.
	ClientURLs    []string `protobuf:"bytes,4,rep,name=clientURLs,proto3" json:"clientURLs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Member) Reset() {
	*x = Member{}
	mi := &file_regatta_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Member) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Member) ProtoMessage() {}

func (x *Member) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Member.ProtoReflect.Descriptor instead.
func (*Member) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{11}
}

func (x *Member) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Member) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Member) GetPeerURLs() []string {
	if x != nil {
		return x.PeerURLs
	}
	return nil
}

func (x *Member) GetClientURLs() []string {
	if x != nil {
		return x.ClientURLs
	}
	return nil
}

type TableStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// dbSize is the size of the raft log, in bytes, of the responding member.
	LogSize int64 `protobuf:"varint,2,opt,name=logSize,proto3" json:"logSize,omitempty"`
	// dbSize is the size of the backend database physically allocated, in bytes, of the responding member.
	DbSize int64 `protobuf:"varint,3,opt,name=dbSize,proto3" json:"dbSize,omitempty"`
	// leader is the member ID which the responding member believes is the current leader.
	Leader string `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	// raftIndex is the current raft committed index of the responding member.
	RaftIndex uint64 `protobuf:"varint,5,opt,name=raftIndex,proto3" json:"raftIndex,omitempty"`
	// raftTerm is the current raft term of the responding member.
	RaftTerm uint64 `protobuf:"varint,6,opt,name=raftTerm,proto3" json:"raftTerm,omitempty"`
	// raftAppliedIndex is the current raft applied index of the responding member.
	RaftAppliedIndex uint64 `protobuf:"varint,7,opt,name=raftAppliedIndex,proto3" json:"raftAppliedIndex,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *TableStatus) Reset() {
	*x = TableStatus{}
	mi := &file_regatta_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TableStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableStatus) ProtoMessage() {}

func (x *TableStatus) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableStatus.ProtoReflect.Descriptor instead.
func (*TableStatus) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{12}
}

func (x *TableStatus) GetLogSize() int64 {
	if x != nil {
		return x.LogSize
	}
	return 0
}

func (x *TableStatus) GetDbSize() int64 {
	if x != nil {
		return x.DbSize
	}
	return 0
}

func (x *TableStatus) GetLeader() string {
	if x != nil {
		return x.Leader
	}
	return ""
}

func (x *TableStatus) GetRaftIndex() uint64 {
	if x != nil {
		return x.RaftIndex
	}
	return 0
}

func (x *TableStatus) GetRaftTerm() uint64 {
	if x != nil {
		return x.RaftTerm
	}
	return 0
}

func (x *TableStatus) GetRaftAppliedIndex() uint64 {
	if x != nil {
		return x.RaftAppliedIndex
	}
	return 0
}

type StatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// config controls if the configuration values should be fetched as well.
	Config        bool `protobuf:"varint,4,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusRequest) Reset() {
	*x = StatusRequest{}
	mi := &file_regatta_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusRequest) ProtoMessage() {}

func (x *StatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusRequest.ProtoReflect.Descriptor instead.
func (*StatusRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{13}
}

func (x *StatusRequest) GetConfig() bool {
	if x != nil {
		return x.Config
	}
	return false
}

type StatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the member ID of this member.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// version is the semver version used by the responding member.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// info is the additional server info.
	Info string `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	// tables is a status of tables of the responding member.
	Tables map[string]*TableStatus `protobuf:"bytes,4,rep,name=tables,proto3" json:"tables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// config the node configuration values.
	Config *structpb.Struct `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`
	// errors contains alarm/health information and status.
	Errors        []string `protobuf:"bytes,8,rep,name=errors,proto3" json:"errors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusResponse) Reset() {
	*x = StatusResponse{}
	mi := &file_regatta_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusResponse) ProtoMessage() {}

func (x *StatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{14}
}

func (x *StatusResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *StatusResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *StatusResponse) GetInfo() string {
	if x != nil {
		return x.Info
	}
	return ""
}

func (x *StatusResponse) GetTables() map[string]*TableStatus {
	if x != nil {
		return x.Tables
	}
	return nil
}

func (x *StatusResponse) GetConfig() *structpb.Struct {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *StatusResponse) GetErrors() []string {
	if x != nil {
		return x.Errors
	}
	return nil
}

// CreateTableRequest describes the table to be created.
type CreateTableRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the table to be created.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// config the table configuration values.
	Config        *structpb.Struct `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTableRequest) Reset() {
	*x = CreateTableRequest{}
	mi := &file_regatta_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTableRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTableRequest) ProtoMessage() {}

func (x *CreateTableRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTableRequest.ProtoReflect.Descriptor instead.
func (*CreateTableRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{15}
}

func (x *CreateTableRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateTableRequest) GetConfig() *structpb.Struct {
	if x != nil {
		return x.Config
	}
	return nil
}

// CreateTableResponse describes the newly created table.
type CreateTableResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id the created table.
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTableResponse) Reset() {
	*x = CreateTableResponse{}
	mi := &file_regatta_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTableResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTableResponse) ProtoMessage() {}

func (x *CreateTableResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTableResponse.ProtoReflect.Descriptor instead.
func (*CreateTableResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{16}
}

func (x *CreateTableResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// DeleteTableRequest describes the table to be deleted.
type DeleteTableRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the table to be deleted.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteTableRequest) Reset() {
	*x = DeleteTableRequest{}
	mi := &file_regatta_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteTableRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteTableRequest) ProtoMessage() {}

func (x *DeleteTableRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteTableRequest.ProtoReflect.Descriptor instead.
func (*DeleteTableRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{17}
}

func (x *DeleteTableRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// DeleteTableResponse when the table was successfully deleted.
type DeleteTableResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteTableResponse) Reset() {
	*x = DeleteTableResponse{}
	mi := &file_regatta_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteTableResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteTableResponse) ProtoMessage() {}

func (x *DeleteTableResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteTableResponse.ProtoReflect.Descriptor instead.
func (*DeleteTableResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{18}
}

// ListTablesRequest requests the list of currently registered tables.
type ListTablesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTablesRequest) Reset() {
	*x = ListTablesRequest{}
	mi := &file_regatta_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTablesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTablesRequest) ProtoMessage() {}

func (x *ListTablesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTablesRequest.ProtoReflect.Descriptor instead.
func (*ListTablesRequest) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{19}
}

// TableInfo describes a single table.
type TableInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name of the table.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// id of the table.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// config the table configuration values.
	Config        *structpb.Struct `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TableInfo) Reset() {
	*x = TableInfo{}
	mi := &file_regatta_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TableInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableInfo) ProtoMessage() {}

func (x *TableInfo) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableInfo.ProtoReflect.Descriptor instead.
func (*TableInfo) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{20}
}

func (x *TableInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TableInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *TableInfo) GetConfig() *structpb.Struct {
	if x != nil {
		return x.Config
	}
	return nil
}

// FollowerGetTablesResponse contains information about tables stored in the cluster.
type ListTablesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tables        []*TableInfo           `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListTablesResponse) Reset() {
	*x = ListTablesResponse{}
	mi := &file_regatta_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListTablesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListTablesResponse) ProtoMessage() {}

func (x *ListTablesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_regatta_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListTablesResponse.ProtoReflect.Descriptor instead.
func (*ListTablesResponse) Descriptor() ([]byte, []int) {
	return file_regatta_proto_rawDescGZIP(), []int{21}
}

func (x *ListTablesResponse) GetTables() []*TableInfo {
	if x != nil {
		return x.Tables
	}
	return nil
}

var File_regatta_proto protoreflect.FileDescriptor

const file_regatta_proto_rawDesc = "" +
	"\n" +
	"\rregatta.proto\x12\n" +
	"regatta.v1\x1a\n" +
	"mvcc.proto\x1a\x1cgoogle/protobuf/struct.proto\"\xa9\x01\n" +
	"\x0eResponseHeader\x12\x19\n" +
	"\bshard_id\x18\x01 \x01(\x04R\ashardId\x12\x1d\n" +
	"\n" +
	"replica_id\x18\x02 \x01(\x04R\treplicaId\x12\x1a\n" +
	"\brevision\x18\x03 \x01(\x04R\brevision\x12\x1b\n" +
	"\traft_term\x18\x04 \x01(\x04R\braftTerm\x12$\n" +
	"\x0eraft_leader_id\x18\x05 \x01(\x04R\fraftLeaderId\"\xfd\x02\n" +
	"\fRangeRequest\x12\x14\n" +
	"\x05table\x18\x01 \x01(\fR\x05table\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x1b\n" +
	"\trange_end\x18\x03 \x01(\fR\brangeEnd\x12\x14\n" +
	"\x05limit\x18\x04 \x01(\x03R\x05limit\x12\"\n" +
	"\flinearizable\x18\x05 \x01(\bR\flinearizable\x12\x1b\n" +
	"\tkeys_only\x18\x06 \x01(\bR\bkeysOnly\x12\x1d\n" +
	"\n" +
	"count_only\x18\a \x01(\bR\tcountOnly\x12(\n" +
	"\x10min_mod_revision\x18\b \x01(\x03R\x0eminModRevision\x12(\n" +
	"\x10max_mod_revision\x18\t \x01(\x03R\x0emaxModRevision\x12.\n" +
	"\x13min_create_revision\x18\n" +
	" \x01(\x03R\x11minCreateRevision\x12.\n" +
	"\x13max_create_revision\x18\v \x01(\x03R\x11maxCreateRevision\"\x92\x01\n" +
	"\rRangeResponse\x122\n" +
	"\x06header\x18\x01 \x01(\v2\x1a.regatta.v1.ResponseHeaderR\x06header\x12#\n" +
	"\x03kvs\x18\x03 \x03(\v2\x11.mvcc.v1.KeyValueR\x03kvs\x12\x12\n" +
	"\x04more\x18\x04 \x01(\bR\x04more\x12\x14\n" +
	"\x05count\x18\x05 \x01(\x03R\x05count\"c\n" +
	"\n" +
	"PutRequest\x12\x14\n" +
	"\x05table\x18\x01 \x01(\fR\x05table\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05value\x12\x17\n" +
	"\aprev_kv\x18\x04 \x01(\bR\x06prevKv\"m\n" +
	"\vPutResponse\x122\n" +
	"\x06header\x18\x01 \x01(\v2\x1a.regatta.v1.ResponseHeaderR\x06header\x12*\n" +
	"\aprev_kv\x18\x02 \x01(\v2\x11.mvcc.v1.KeyValueR\x06prevKv\"\x88\x01\n" +
	"\x12DeleteRangeRequest\x12\x14\n" +
	"\x05table\x18\x01 \x01(\fR\x05table\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x1b\n" +
	"\trange_end\x18\x03 \x01(\fR\brangeEnd\x12\x17\n" +
	"\aprev_kv\x18\x04 \x01(\bR\x06prevKv\x12\x14\n" +
	"\x05count\x18\x05 \x01(\bR\x05count\"\x91\x01\n" +
	"\x13DeleteRangeResponse\x122\n" +
	"\x06header\x18\x01 \x01(\v2\x1a.regatta.v1.ResponseHeaderR\x06header\x12\x18\n" +
	"\adeleted\x18\x02 \x01(\x03R\adeleted\x12,\n" +
	"\bprev_kvs\x18\x03 \x03(\v2\x11.mvcc.v1.KeyValueR\aprevKvs\"\xaa\x01\n" +
	"\n" +
	"TxnRequest\x12\x14\n" +
	"\x05table\x18\x01 \x01(\fR\x05table\x12*\n" +
	"\acompare\x18\x02 \x03(\v2\x10.mvcc.v1.CompareR\acompare\x12,\n" +
	"\asuccess\x18\x03 \x03(\v2\x12.mvcc.v1.RequestOpR\asuccess\x12,\n" +
	"\afailure\x18\x04 \x03(\v2\x12.mvcc.v1.RequestOpR\afailure\"\x92\x01\n" +
	"\vTxnResponse\x122\n" +
	"\x06header\x18\x01 \x01(\v2\x1a.regatta.v1.ResponseHeaderR\x06header\x12\x1c\n" +
	"\tsucceeded\x18\x02 \x01(\bR\tsucceeded\x121\n" +
	"\tresponses\x18\x03 \x03(\v2\x13.mvcc.v1.ResponseOpR\tresponses\"\x13\n" +
	"\x11MemberListRequest\"\\\n" +
	"\x12MemberListResponse\x12\x18\n" +
	"\acluster\x18\x01 \x01(\tR\acluster\x12,\n" +
	"\amembers\x18\x02 \x03(\v2\x12.regatta.v1.MemberR\amembers\"h\n" +
	"\x06Member\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1a\n" +
	"\bpeerURLs\x18\x03 \x03(\tR\bpeerURLs\x12\x1e\n" +
	"\n" +
	"clientURLs\x18\x04 \x03(\tR\n" +
	"clientURLs\"\xbd\x01\n" +
	"\vTableStatus\x12\x18\n" +
	"\alogSize\x18\x02 \x01(\x03R\alogSize\x12\x16\n" +
	"\x06dbSize\x18\x03 \x01(\x03R\x06dbSize\x12\x16\n" +
	"\x06leader\x18\x04 \x01(\tR\x06leader\x12\x1c\n" +
	"\traftIndex\x18\x05 \x01(\x04R\traftIndex\x12\x1a\n" +
	"\braftTerm\x18\x06 \x01(\x04R\braftTerm\x12*\n" +
	"\x10raftAppliedIndex\x18\a \x01(\x04R\x10raftAppliedIndex\"'\n" +
	"\rStatusRequest\x12\x16\n" +
	"\x06config\x18\x04 \x01(\bR\x06config\"\xab\x02\n" +
	"\x0eStatusResponse\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x12\n" +
	"\x04info\x18\x03 \x01(\tR\x04info\x12>\n" +
	"\x06tables\x18\x04 \x03(\v2&.regatta.v1.StatusResponse.TablesEntryR\x06tables\x12/\n" +
	"\x06config\x18\x05 \x01(\v2\x17.google.protobuf.StructR\x06config\x12\x16\n" +
	"\x06errors\x18\b \x03(\tR\x06errors\x1aR\n" +
	"\vTablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12-\n" +
	"\x05value\x18\x02 \x01(\v2\x17.regatta.v1.TableStatusR\x05value:\x028\x01\"Y\n" +
	"\x12CreateTableRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12/\n" +
	"\x06config\x18\x05 \x01(\v2\x17.google.protobuf.StructR\x06config\"%\n" +
	"\x13CreateTableResponse\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"(\n" +
	"\x12DeleteTableRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\"\x15\n" +
	"\x13DeleteTableResponse\"\x13\n" +
	"\x11ListTablesRequest\"`\n" +
	"\tTableInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\x12/\n" +
	"\x06config\x18\x05 \x01(\v2\x17.google.protobuf.StructR\x06config\"C\n" +
	"\x12ListTablesResponse\x12-\n" +
	"\x06tables\x18\x01 \x03(\v2\x15.regatta.v1.TableInfoR\x06tables2\xc9\x02\n" +
	"\x02KV\x12<\n" +
	"\x05Range\x12\x18.regatta.v1.RangeRequest\x1a\x19.regatta.v1.RangeResponse\x12E\n" +
	"\fIterateRange\x12\x18.regatta.v1.RangeRequest\x1a\x19.regatta.v1.RangeResponse0\x01\x126\n" +
	"\x03Put\x12\x16.regatta.v1.PutRequest\x1a\x17.regatta.v1.PutResponse\x12N\n" +
	"\vDeleteRange\x12\x1e.regatta.v1.DeleteRangeRequest\x1a\x1f.regatta.v1.DeleteRangeResponse\x126\n" +
	"\x03Txn\x12\x16.regatta.v1.TxnRequest\x1a\x17.regatta.v1.TxnResponse2\x97\x01\n" +
	"\aCluster\x12K\n" +
	"\n" +
	"MemberList\x12\x1d.regatta.v1.MemberListRequest\x1a\x1e.regatta.v1.MemberListResponse\x12?\n" +
	"\x06Status\x12\x19.regatta.v1.StatusRequest\x1a\x1a.regatta.v1.StatusResponse2\xe5\x01\n" +
	"\x06Tables\x12I\n" +
	"\x06Create\x12\x1e.regatta.v1.CreateTableRequest\x1a\x1f.regatta.v1.CreateTableResponse\x12I\n" +
	"\x06Delete\x12\x1e.regatta.v1.DeleteTableRequest\x1a\x1f.regatta.v1.DeleteTableResponse\x12E\n" +
	"\x04List\x12\x1d.regatta.v1.ListTablesRequest\x1a\x1e.regatta.v1.ListTablesResponseB\rZ\v./regattapbb\x06proto3"

var (
	file_regatta_proto_rawDescOnce sync.Once
	file_regatta_proto_rawDescData []byte
)

func file_regatta_proto_rawDescGZIP() []byte {
	file_regatta_proto_rawDescOnce.Do(func() {
		file_regatta_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_regatta_proto_rawDesc), len(file_regatta_proto_rawDesc)))
	})
	return file_regatta_proto_rawDescData
}

var file_regatta_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_regatta_proto_goTypes = []any{
	(*ResponseHeader)(nil),      // 0: regatta.v1.ResponseHeader
	(*RangeRequest)(nil),        // 1: regatta.v1.RangeRequest
	(*RangeResponse)(nil),       // 2: regatta.v1.RangeResponse
	(*PutRequest)(nil),          // 3: regatta.v1.PutRequest
	(*PutResponse)(nil),         // 4: regatta.v1.PutResponse
	(*DeleteRangeRequest)(nil),  // 5: regatta.v1.DeleteRangeRequest
	(*DeleteRangeResponse)(nil), // 6: regatta.v1.DeleteRangeResponse
	(*TxnRequest)(nil),          // 7: regatta.v1.TxnRequest
	(*TxnResponse)(nil),         // 8: regatta.v1.TxnResponse
	(*MemberListRequest)(nil),   // 9: regatta.v1.MemberListRequest
	(*MemberListResponse)(nil),  // 10: regatta.v1.MemberListResponse
	(*Member)(nil),              // 11: regatta.v1.Member
	(*TableStatus)(nil),         // 12: regatta.v1.TableStatus
	(*StatusRequest)(nil),       // 13: regatta.v1.StatusRequest
	(*StatusResponse)(nil),      // 14: regatta.v1.StatusResponse
	(*CreateTableRequest)(nil),  // 15: regatta.v1.CreateTableRequest
	(*CreateTableResponse)(nil), // 16: regatta.v1.CreateTableResponse
	(*DeleteTableRequest)(nil),  // 17: regatta.v1.DeleteTableRequest
	(*DeleteTableResponse)(nil), // 18: regatta.v1.DeleteTableResponse
	(*ListTablesRequest)(nil),   // 19: regatta.v1.ListTablesRequest
	(*TableInfo)(nil),           // 20: regatta.v1.TableInfo
	(*ListTablesResponse)(nil),  // 21: regatta.v1.ListTablesResponse
	nil,                         // 22: regatta.v1.StatusResponse.TablesEntry
	(*KeyValue)(nil),            // 23: mvcc.v1.KeyValue
	(*Compare)(nil),             // 24: mvcc.v1.Compare
	(*RequestOp)(nil),           // 25: mvcc.v1.RequestOp
	(*ResponseOp)(nil),          // 26: mvcc.v1.ResponseOp
	(*structpb.Struct)(nil),     // 27: google.protobuf.Struct
}
var file_regatta_proto_depIdxs = []int32{
	0,  // 0: regatta.v1.RangeResponse.header:type_name -> regatta.v1.ResponseHeader
	23, // 1: regatta.v1.RangeResponse.kvs:type_name -> mvcc.v1.KeyValue
	0,  // 2: regatta.v1.PutResponse.header:type_name -> regatta.v1.ResponseHeader
	23, // 3: regatta.v1.PutResponse.prev_kv:type_name -> mvcc.v1.KeyValue
	0,  // 4: regatta.v1.DeleteRangeResponse.header:type_name -> regatta.v1.ResponseHeader
	23, // 5: regatta.v1.DeleteRangeResponse.prev_kvs:type_name -> mvcc.v1.KeyValue
	24, // 6: regatta.v1.TxnRequest.compare:type_name -> mvcc.v1.Compare
	25, // 7: regatta.v1.TxnRequest.success:type_name -> mvcc.v1.RequestOp
	25, // 8: regatta.v1.TxnRequest.failure:type_name -> mvcc.v1.RequestOp
	0,  // 9: regatta.v1.TxnResponse.header:type_name -> regatta.v1.ResponseHeader
	26, // 10: regatta.v1.TxnResponse.responses:type_name -> mvcc.v1.ResponseOp
	11, // 11: regatta.v1.MemberListResponse.members:type_name -> regatta.v1.Member
	22, // 12: regatta.v1.StatusResponse.tables:type_name -> regatta.v1.StatusResponse.TablesEntry
	27, // 13: regatta.v1.StatusResponse.config:type_name -> google.protobuf.Struct
	27, // 14: regatta.v1.CreateTableRequest.config:type_name -> google.protobuf.Struct
	27, // 15: regatta.v1.TableInfo.config:type_name -> google.protobuf.Struct
	20, // 16: regatta.v1.ListTablesResponse.tables:type_name -> regatta.v1.TableInfo
	12, // 17: regatta.v1.StatusResponse.TablesEntry.value:type_name -> regatta.v1.TableStatus
	1,  // 18: regatta.v1.KV.Range:input_type -> regatta.v1.RangeRequest
	1,  // 19: regatta.v1.KV.IterateRange:input_type -> regatta.v1.RangeRequest
	3,  // 20: regatta.v1.KV.Put:input_type -> regatta.v1.PutRequest
	5,  // 21: regatta.v1.KV.DeleteRange:input_type -> regatta.v1.DeleteRangeRequest
	7,  // 22: regatta.v1.KV.Txn:input_type -> regatta.v1.TxnRequest
	9,  // 23: regatta.v1.Cluster.MemberList:input_type -> regatta.v1.MemberListRequest
	13, // 24: regatta.v1.Cluster.Status:input_type -> regatta.v1.StatusRequest
	15, // 25: regatta.v1.Tables.Create:input_type -> regatta.v1.CreateTableRequest
	17, // 26: regatta.v1.Tables.Delete:input_type -> regatta.v1.DeleteTableRequest
	19, // 27: regatta.v1.Tables.List:input_type -> regatta.v1.ListTablesRequest
	2,  // 28: regatta.v1.KV.Range:output_type -> regatta.v1.RangeResponse
	2,  // 29: regatta.v1.KV.IterateRange:output_type -> regatta.v1.RangeResponse
	4,  // 30: regatta.v1.KV.Put:output_type -> regatta.v1.PutResponse
	6,  // 31: regatta.v1.KV.DeleteRange:output_type -> regatta.v1.DeleteRangeResponse
	8,  // 32: regatta.v1.KV.Txn:output_type -> regatta.v1.TxnResponse
	10, // 33: regatta.v1.Cluster.MemberList:output_type -> regatta.v1.MemberListResponse
	14, // 34: regatta.v1.Cluster.Status:output_type -> regatta.v1.StatusResponse
	16, // 35: regatta.v1.Tables.Create:output_type -> regatta.v1.CreateTableResponse
	18, // 36: regatta.v1.Tables.Delete:output_type -> regatta.v1.DeleteTableResponse
	21, // 37: regatta.v1.Tables.List:output_type -> regatta.v1.ListTablesResponse
	28, // [28:38] is the sub-list for method output_type
	18, // [18:28] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_regatta_proto_init() }
func file_regatta_proto_init() {
	if File_regatta_proto != nil {
		return
	}
	file_mvcc_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_regatta_proto_rawDesc), len(file_regatta_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   23,
			NumExtensions: 0,
			NumServices:   3,
		},
		GoTypes:           file_regatta_proto_goTypes,
		DependencyIndexes: file_regatta_proto_depIdxs,
		MessageInfos:      file_regatta_proto_msgTypes,
	}.Build()
	File_regatta_proto = out.File
	file_regatta_proto_goTypes = nil
	file_regatta_proto_depIdxs = nil
}
